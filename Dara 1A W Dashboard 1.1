Excellent! Now we have the complete picture. Let me address each point.

---

## 1. The 5 SAWV Scales Defined

```
╔═══════════════════════════════════════════════════════════════════════════════════╗
║                         WVM - 5 WORLDVIEW DIMENSIONS                              ║
╠═══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                   ║
║  SCALE 1: HUMAN NATURE                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │    -5              -2.5              0              +2.5              +5     │  ║
║  │     │                │               │                │                │     │  ║
║  │  Humans          Humans are       Neutral/         Humans are       Humans   │  ║
║  │  are Bad         Mostly Bad       Mixed            Mostly Good      are Good │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
║  SCALE 2: CONTROL ORIENTATION                                                     ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │    -5              -2.5              0              +2.5              +5     │  ║
║  │     │                │               │                │                │     │  ║
║  │  External        Mostly           Balance          Mostly           Full     │  ║
║  │  Control         Controlled                        Autonomous       Autonomy │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
║  SCALE 3: TEMPORAL ORIENTATION                                                    ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │    -5              -2.5              0              +2.5              +5     │  ║
║  │     │                │               │                │                │     │  ║
║  │  Fully           Mostly           Flexible         Mostly           Fully    │  ║
║  │  Spontaneous     Spontaneous                       Planned          Planned  │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
║  SCALE 4: AGENCY BELIEF                                                           ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │    -5              -2.5              0              +2.5              +5     │  ║
║  │     │                │               │                │                │     │  ║
║  │  No Agency       Limited          Conditional      Strong           Full     │  ║
║  │  (Determinism)   Agency           Agency           Agency           Agency   │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
║  SCALE 5: [UNDEFINED - Need 5th dimension]                                        ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │    -5              -2.5              0              +2.5              +5     │  ║
║  │     │                │               │                │                │     │  ║
║  │     ?                ?               ?                ?                ?     │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
╚═══════════════════════════════════════════════════════════════════════════════════╝
```

**Question:** You listed 4 scales. What is the 5th? Common SAWV dimensions include:
- **Interconnectedness** (Isolated ↔ Connected)
- **Change Orientation** (Static ↔ Dynamic)
- **Trust** (Distrust ↔ Trust)
- **Meaning** (Meaningless ↔ Meaningful)

---

## 2. Cycle Definition Formalized

```
╔═══════════════════════════════════════════════════════════════════════════════════╗
║                              ASU CYCLE DEFINITION                                 ║
╠═══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                   ║
║  ONE CYCLE = ONE COMPLETE ITERATION                                               ║
║                                                                                   ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │                                                                             │  ║
║  │  PHASE 1: NARRATIVE INPUT                                                   │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ Receive RL Narrative (Beginning, Middle, End, Moral)                │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 2: INTERPRETATION                                                    │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ DARA processes narrative through current WVM lens                   │    │  ║
║  │  │ Extracts meaning relative to 5 worldview scales                     │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 3: CONCLUSION                                                        │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ DARA forms conclusion about narrative                               │    │  ║
║  │  │ Records in Memory Module (structured template)                      │    │  ║
║  │  │ Updates Buffer Tier (5 scales)                                      │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 4: MEASUREMENT                                                       │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ Calculate drift (Buffer vs Active vs Anchor)                        │    │  ║
║  │  │ Update ASM (Valence/Arousal based on narrative emotional content)   │    │  ║
║  │  │ Calculate Dissonance Register                                       │    │  ║
║  │  │ Calculate Composite Score                                           │    │  ║
║  │  │ Evaluate Stability Index                                            │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 5: ADJUSTMENT CHECK                                                  │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ IF stability outside tolerance:                                     │    │  ║
║  │  │    Trigger Adjustment Module                                        │    │  ║
║  │  │    Apply resolution strategy                                        │    │  ║
║  │  │ ELSE:                                                               │    │  ║
║  │  │    Continue                                                         │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 6: PROPAGATION CHECK                                                 │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ IF Buffer stable for N cycles:                                      │    │  ║
║  │  │    Promote to Active Tier                                           │    │  ║
║  │  │ IF Active contradicted:                                             │    │  ║
║  │  │    Demote to Buffer                                                 │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │  PHASE 7: LOGGING                                                           │  ║
║  │  ┌─────────────────────────────────────────────────────────────────────┐    │  ║
║  │  │ Create Iteration Data Package                                       │    │  ║
║  │  │ Assign Iteration Timestamp                                          │    │  ║
║  │  │ Store in Memory Module                                              │    │  ║
║  │  └─────────────────────────────────────────────────────────────────────┘    │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │                     [CYCLE COMPLETE]                                        │  ║
║  │                              │                                              │  ║
║  │                              ▼                                              │  ║
║  │                   [AWAIT NEXT NARRATIVE]                                    │  ║
║  │                                                                             │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
╚═══════════════════════════════════════════════════════════════════════════════════╝
```

---

## 3. Language Recommendation

### Python is the Right Choice

| Factor | Python | Alternatives | Verdict |
|--------|--------|--------------|---------|
| **Your readability** | ✓ You can read it | Would need learning | Python wins |
| **Data science ecosystem** | NumPy, Pandas, Matplotlib | Varies | Python wins |
| **Rapid prototyping** | Excellent | Varies | Python wins |
| **LLM integration** | OpenAI, Anthropic APIs native | Available but less mature | Python wins |
| **Dashboard options** | Streamlit, Gradio, Dash | Varies | Python wins |
| **Future ML integration** | PyTorch, TensorFlow ready | Possible | Python wins |

### Recommended Stack

```
╔═══════════════════════════════════════════════════════════════════════════════════╗
║                         DARA 1A - TECHNICAL STACK                                 ║
╠═══════════════════════════════════════════════════════════════════════════════════╣
║                                                                                   ║
║  CORE LANGUAGE: Python 3.10+                                                      ║
║                                                                                   ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │  LAYER              LIBRARY              PURPOSE                            │  ║
║  ├─────────────────────────────────────────────────────────────────────────────┤  ║
║  │  Data Structures    dataclasses          Clean state objects                │  ║
║  │                     pydantic             Validation & serialization         │  ║
║  │                                                                             │  ║
║  │  Numerical          numpy                Scale calculations                 │  ║
║  │                                                                             │  ║
║  │  Data Storage       json                 Config & state persistence         │  ║
║  │                     sqlite3              Iteration history (built-in)       │  ║
║  │                                                                             │  ║
║  │  Visualization      matplotlib           Static charts                      │  ║
║  │                     plotly               Interactive charts                 │  ║
║  │                                                                             │  ║
║  │  Dashboard          streamlit            Rapid UI (recommended)             │  ║
║  │                     OR gradio            Alternative (simpler)              │  ║
║  │                                                                             │  ║
║  │  LLM Integration    anthropic            Claude API (for DARA reasoning)    │  ║
║  │                     OR openai            GPT API alternative                │  ║
║  │                                                                             │  ║
║  │  Testing            pytest               Unit tests                         │  ║
║  │                                                                             │  ║
║  │  Logging            logging (built-in)   Event tracking                     │  ║
║  └─────────────────────────────────────────────────────────────────────────────┘  ║
║                                                                                   ║
║  FILE STRUCTURE                                                                   ║
║  ┌─────────────────────────────────────────────────────────────────────────────┐  ║
║  │                                                                             │  ║
║  │  dara/                                                                      │  ║
║  │  ├── __init__.py                                                            │  ║
║  │  ├── core/                                                                  │  ║
║  │  │   ├── __init__.py                                                        │  ║
║  │  │   ├── models.py            # Data structures (WVM, ASM, etc.)            │  ║
║  │  │   ├── wvm.py               # Worldview Module logic                      │  ║
║  │  │   ├── asm.py               # Affective State Module logic                │  ║
║  │  │   ├── dissonance.py        # Dissonance Register logic                   │  ║
║  │  │   ├── adjustment.py        # Adjustment Module logic                     │  ║
║  │  │   └── cycle.py             # ASU Cycle orchestration                     │  ║
║  │  │                                                                          │  ║
║  │  ├── memory/                                                                │  ║
║  │  │   ├── __init__.py                                                        │  ║
║  │  │   ├── storage.py           # Iteration data persistence                  │  ║
║  │  │   └── templates.py         # Conclusion templates                        │  ║
║  │  │                                                                          │  ║
║  │  ├── config/                                                                │  ║
║  │  │   ├── __init__.py                                                        │  ║
║  │  │   ├── defaults.py          # Default parameter values                    │  ║
║  │  │   └── schema.py            # Configuration validation                    │  ║
║  │  │                                                                          │  ║
║  │  ├── dashboard/                                                             │  ║
║  │  │   ├── __init__.py                                                        │  ║
║  │  │   └── app.py               # Streamlit dashboard                         │  ║
║  │  │                                                                          │  ║
║  │  ├── experiments/                                                           │  ║
║  │  │   ├── __init__.py                                                        │  ║
║  │  │   └── runner.py            # Experiment orchestration                    │  ║
║  │  │                                                                          │  ║
║  │  └── utils/                                                                 │  ║
║  │      ├── __init__.py                                                        │  ║
║  │      └── calculations.py      # Drift, composite score, etc.                │  ║
║  │                                                                             │  ║
║  ├── data/                                                                     │  ║
║  │   ├── narratives/             # Input stories                               │  ║
║  │   ├── configs/                # Saved configurations                        │  ║
║  │   └── iterations/             # Iteration logs                              │  ║
║  │                                                                             │  ║
║  ├── tests/                                                                    │  ║
║  │   └── ...                                                                   │  ║
║  │                                                                             │  ║
║  ├── main.py                     # Entry point                                 │  ║
║  ├── requirements.txt                                                          │  ║
║  └── README.md                                                                 │  ║
║                                                                                   ║
╚═══════════════════════════════════════════════════════════════════════════════════╝
```

---

## 4. Core Data Schema (Python)

I have capacity to provide the full schema. Here's the foundation:

```python
# dara/core/models.py

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from datetime import datetime
from enum import Enum
import uuid


# =============================================================================
# ENUMS
# =============================================================================

class StabilityStatus(Enum):
    STABLE = "stable"
    DRIFTING = "drifting"
    OSCILLATING = "oscillating"
    FROZEN = "frozen"
    ADJUSTING = "adjusting"


class AdjustmentStrategy(Enum):
    REFRAME = "reframe"
    SEEK_CLARITY = "seek_clarity"
    ACCEPT_AMBIGUITY = "accept_ambiguity"


class PropagationDirection(Enum):
    PROMOTE = "buffer_to_active"
    DEMOTE = "active_to_buffer"
    NONE = "none"


# =============================================================================
# WORLDVIEW MODULE (WVM)
# =============================================================================

@dataclass
class WorldviewScales:
    """5 SAWV scales representing worldview dimensions."""
    
    human_nature: float = 0.0       # Scale 1: Bad (-5) to Good (+5)
    control_orientation: float = 0.0 # Scale 2: Controlling (-5) to Autonomy (+5)
    temporal_orientation: float = 0.0 # Scale 3: Spontaneous (-5) to Planned (+5)
    agency_belief: float = 0.0       # Scale 4: No Agency (-5) to Full Agency (+5)
    scale_5: float = 0.0             # Scale 5: [TBD] (-5) to [TBD] (+5)
    
    def to_dict(self) -> Dict[str, float]:
        return {
            "human_nature": self.human_nature,
            "control_orientation": self.control_orientation,
            "temporal_orientation": self.temporal_orientation,
            "agency_belief": self.agency_belief,
            "scale_5": self.scale_5
        }
    
    def to_list(self) -> List[float]:
        return [
            self.human_nature,
            self.control_orientation,
            self.temporal_orientation,
            self.agency_belief,
            self.scale_5
        ]
    
    @classmethod
    def from_dict(cls, data: Dict[str, float]) -> 'WorldviewScales':
        return cls(**data)


@dataclass
class WVMTier:
    """A single tier in the WVM (Anchor, Active, or Buffer)."""
    
    name: str
    scales: WorldviewScales
    is_mutable: bool = True
    last_updated: Optional[datetime] = None
    
    def update_scales(self, new_scales: WorldviewScales) -> None:
        if not self.is_mutable:
            raise ValueError(f"Cannot modify immutable tier: {self.name}")
        self.scales = new_scales
        self.last_updated = datetime.now()


@dataclass
class WVM:
    """Complete Worldview Module with 3 tiers."""
    
    anchor: WVMTier = field(default_factory=lambda: WVMTier(
        name="anchor",
        scales=WorldviewScales(),
        is_mutable=False
    ))
    active: WVMTier = field(default_factory=lambda: WVMTier(
        name="active",
        scales=WorldviewScales(),
        is_mutable=True
    ))
    buffer: WVMTier = field(default_factory=lambda: WVMTier(
        name="buffer",
        scales=WorldviewScales(),
        is_mutable=True
    ))


# =============================================================================
# AFFECTIVE STATE MODULE (ASM)
# =============================================================================

@dataclass
class ASM:
    """Affective State Module - Circumplex model."""
    
    valence: float = 0.0    # -9 (Unpleasant) to +9 (Pleasant)
    arousal: float = 0.0    # -9 (Low energy) to +9 (High energy)
    
    def is_within_tolerance(self, tolerance: float) -> bool:
        return abs(self.valence) <= tolerance and abs(self.arousal) <= tolerance
    
    def distance_from_equilibrium(self) -> float:
        """Euclidean distance from origin (0,0)."""
        return (self.valence**2 + self.arousal**2)**0.5


# =============================================================================
# DISSONANCE REGISTER
# =============================================================================

@dataclass
class DissonanceRegister:
    """Tracks dissonance between WVM tiers."""
    
    current_level: float = 0.0          # 0-100%
    previous_level: float = 0.0
    delta: float = 0.0                   # Change from previous
    sustained_cycles: int = 0            # Cycles at similar level
    trend: str = "stable"                # rising, falling, stable
    
    def update(self, new_level: float, stability_band: float = 5.0) -> None:
        self.previous_level = self.current_level
        self.current_level = new_level
        self.delta = new_level - self.previous_level
        
        if abs(self.delta) < stability_band:
            self.sustained_cycles += 1
            self.trend = "stable"
        else:
            self.sustained_cycles = 0
            self.trend = "rising" if self.delta > 0 else "falling"


# =============================================================================
# DRIFT MONITOR
# =============================================================================

@dataclass
class DriftReport:
    """Per-scale drift measurements."""
    
    scale_name: str
    anchor_value: float
    active_value: float
    buffer_value: float
    drift_anchor_to_active: float    # Percentage
    drift_anchor_to_buffer: float    # Percentage
    drift_active_to_buffer: float    # Percentage


@dataclass
class DriftMonitor:
    """Complete drift analysis across all scales."""
    
    scale_reports: List[DriftReport] = field(default_factory=list)
    aggregate_drift_anchor_active: float = 0.0
    aggregate_drift_anchor_buffer: float = 0.0
    aggregate_drift_active_buffer: float = 0.0
    max_drift_scale: Optional[str] = None
    max_drift_value: float = 0.0


# =============================================================================
# STABILITY INDEX
# =============================================================================

@dataclass
class StabilityIndex:
    """Combined stability measurement."""
    
    asm_in_tolerance: bool = True
    dissonance_in_tolerance: bool = True
    drift_in_tolerance: bool = True
    overall_status: StabilityStatus = StabilityStatus.STABLE
    
    @property
    def is_stable(self) -> bool:
        return all([
            self.asm_in_tolerance,
            self.dissonance_in_tolerance,
            self.drift_in_tolerance
        ])


# =============================================================================
# NARRATIVE INPUT
# =============================================================================

@dataclass
class Narrative:
    """Input narrative for RL processing."""
    
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    beginning: str = ""
    middle: str = ""
    end: str = ""
    moral: str = ""
    raw_text: str = ""
    metadata: Dict = field(default_factory=dict)
    
    @property
    def full_text(self) -> str:
        if self.raw_text:
            return self.raw_text
        return f"{self.beginning}\n\n{self.middle}\n\n{self.end}\n\nMoral: {self.moral}"


# =============================================================================
# CONCLUSION
# =============================================================================

@dataclass
class Conclusion:
    """DARA's conclusion from narrative processing."""
    
    narrative_id: str
    summary: str
    worldview_implications: Dict[str, float]  # Scale adjustments implied
    emotional_impact: Dict[str, float]        # Valence/Arousal impact
    confidence: float                          # 0-100%
    reasoning: str
    timestamp: datetime = field(default_factory=datetime.now)


# =============================================================================
# ITERATION DATA PACKAGE
# =============================================================================

@dataclass
class IterationData:
    """Complete state snapshot for one cycle."""
    
    iteration_id: int
    timestamp: datetime
    
    # Input
    narrative: Narrative
    
    # Processing
    conclusion: Conclusion
    
    # State After Processing
    wvm_state: WVM
    asm_state: ASM
    dissonance_state: DissonanceRegister
    drift_state: DriftMonitor
    composite_score: float
    stability_index: StabilityIndex
    
    # Actions Taken
    adjustment_triggered: bool = False
    adjustment_strategy: Optional[AdjustmentStrategy] = None
    propagation_occurred: bool = False
    propagation_direction: PropagationDirection = PropagationDirection.NONE
    propagation_scales: List[str] = field(default_factory=list)
    
    # Events
    events: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        """Serialize for storage."""
        return {
            "iteration_id": self.iteration_id,
            "timestamp": self.timestamp.isoformat(),
            "narrative_id": self.narrative.id,
            "conclusion_summary": self.conclusion.summary,
            "wvm": {
                "anchor": self.wvm_state.anchor.scales.to_dict(),
                "active": self.wvm_state.active.scales.to_dict(),
                "buffer": self.wvm_state.buffer.scales.to_dict()
            },
            "asm": {
                "valence": self.asm_state.valence,
                "arousal": self.asm_state.arousal
            },
            "dissonance": {
                "level": self.dissonance_state.current_level,
                "delta": self.dissonance_state.delta,
                "trend": self.dissonance_state.trend
            },
            "drift": {
                "aggregate_anchor_active": self.drift_state.aggregate_drift_anchor_active,
                "max_drift_scale": self.drift_state.max_drift_scale,
                "max_drift_value": self.drift_state.max_drift_value
            },
            "composite_score": self.composite_score,
            "stability": {
                "status": self.stability_index.overall_status.value,
                "asm_ok": self.stability_index.asm_in_tolerance,
                "dissonance_ok": self.stability_index.dissonance_in_tolerance,
                "drift_ok": self.stability_index.drift_in_tolerance
            },
            "adjustment_triggered": self.adjustment_triggered,
            "adjustment_strategy": self.adjustment_strategy.value if self.adjustment_strategy else None,
            "propagation_occurred": self.propagation_occurred,
            "propagation_direction": self.propagation_direction.value,
            "events": self.events
        }


# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class DashboardConfig:
    """All adjustable parameters."""
    
    # Core Parameters
    stubbornness: float = 0.5           # 0.0 (fluid) to 1.0 (rigid)
    learning_rate: float = 0.5          # 0.0 (slow) to 1.0 (fast)
    emotional_reactivity: float = 0.5   # 0.0 (dampened) to 1.0 (amplified)
    emotional_decay_rate: float = 0.5   # 0.0 (slow) to 1.0 (fast)
    
    # Tier Weights (must sum to 1.0)
    anchor_weight: float = 0.50
    active_weight: float = 0.35
    buffer_weight: float = 0.15
    
    # Tolerances
    asm_tolerance: float = 4.0          # ± from equilibrium
    dissonance_tolerance: float = 30.0  # Percentage
    drift_tolerance: float = 30.0       # Percentage per scale
    aggregate_drift_tolerance: float = 25.0  # Total percentage
    
    # Propagation Rules
    promotion_stability_cycles: int = 10
    promotion_consistency_threshold: float = 85.0  # Percentage
    demotion_contradiction_threshold: float = 30.0  # Percentage
    demotion_grace_period: int = 5
    
    # Dissonance Adjustment
    dissonance_trigger_threshold: float = 20.0
    dissonance_sustained_cycles: int = 3
    
    # Safety Limits
    hard_max_drift: float = 60.0
    hard_max_asm: float = 8.0
    runaway_threshold: float = 10.0     # % change per cycle
    oscillation_reversals: int = 3
    oscillation_window: int = 5
    
    def validate(self) -> bool:
        """Ensure weights sum to 1.0 and values in range."""
        weight_sum = self.anchor_weight + self.active_weight + self.buffer_weight
        if abs(weight_sum - 1.0) > 0.001:
            raise ValueError(f"Tier weights must sum to 1.0, got {weight_sum}")
        
        if not (0.0 <= self.stubbornness <= 1.0):
            raise ValueError("Stubbornness must be between 0.0 and 1.0")
        
        # Add more validations as needed
        return True


# =============================================================================
# DARA INSTANCE
# =============================================================================

@dataclass
class DARAInstance:
    """Complete DARA agent instance."""
    
    instance_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    variant_name: str = "DARA_1A"
    version: str = "0.1.0-alpha"
    created_at: datetime = field(default_factory=datetime.now)
    
    # State
    wvm: WVM = field(default_factory=WVM)
    asm: ASM = field(default_factory=ASM)
    dissonance: DissonanceRegister = field(default_factory=DissonanceRegister)
    
    # Configuration
    config: DashboardConfig = field(default_factory=DashboardConfig)
    
    # History
    iteration_count: int = 0
    iteration_history: List[IterationData] = field(default_factory=list)
```

---

## 5. Core Calculation Functions

```python
# dara/utils/calculations.py

from typing import List, Tuple
import numpy as np
from ..core.models import WorldviewScales, WVM, DriftReport, DriftMonitor


def calculate_scale_drift(value_a: float, value_b: float, scale_range: float = 10.0) -> float:
    """
    Calculate percentage drift between two scale values.
    Scale range is -5 to +5 = 10 total.
    """
    absolute_diff = abs(value_a - value_b)
    percentage = (absolute_diff / scale_range) * 100
    return round(percentage, 2)


def calculate_drift_monitor(wvm: WVM) -> DriftMonitor:
    """Calculate complete drift analysis across all scales."""
    
    anchor = wvm.anchor.scales
    active = wvm.active.scales
    buffer = wvm.buffer.scales
    
    scale_names = [
        "human_nature",
        "control_orientation", 
        "temporal_orientation",
        "agency_belief",
        "scale_5"
    ]
    
    reports = []
    max_drift = 0.0
    max_drift_scale = None
    
    for name in scale_names:
        anchor_val = getattr(anchor, name)
        active_val = getattr(active, name)
        buffer_val = getattr(buffer, name)
        
        drift_a_to_act = calculate_scale_drift(anchor_val, active_val)
        drift_a_to_buf = calculate_scale_drift(anchor_val, buffer_val)
        drift_act_to_buf = calculate_scale_drift(active_val, buffer_val)
        
        report = DriftReport(
            scale_name=name,
            anchor_value=anchor_val,
            active_value=active_val,
            buffer_value=buffer_val,
            drift_anchor_to_active=drift_a_to_act,
            drift_anchor_to_buffer=drift_a_to_buf,
            drift_active_to_buffer=drift_act_to_buf
        )
        reports.append(report)
        
        if drift_a_to_act > max_drift:
            max_drift = drift_a_to_act
            max_drift_scale = name
    
    # Calculate aggregates (average of all scales)
    agg_anchor_active = np.mean([r.drift_anchor_to_active for r in reports])
    agg_anchor_buffer = np.mean([r.drift_anchor_to_buffer for r in reports])
    agg_active_buffer = np.mean([r.drift_active_to_buffer for r in reports])
    
    return DriftMonitor(
        scale_reports=reports,
        aggregate_drift_anchor_active=round(agg_anchor_active, 2),
        aggregate_drift_anchor_buffer=round(agg_anchor_buffer, 2),
        aggregate_drift_active_buffer=round(agg_active_buffer, 2),
        max_drift_scale=max_drift_scale,
        max_drift_value=max_drift
    )


def calculate_composite_score(
    wvm: WVM,
    anchor_weight: float,
    active_weight: float,
    buffer_weight: float
) -> WorldviewScales:
    """
    Calculate weighted composite of all three tiers.
    Returns a WorldviewScales object with composite values.
    """
    anchor = wvm.anchor.scales
    active = wvm.active.scales
    buffer = wvm.buffer.scales
    
    composite = WorldviewScales(
        human_nature=(
            anchor.human_nature * anchor_weight +
            active.human_nature * active_weight +
            buffer.human_nature * buffer_weight
        ),
        control_orientation=(
            anchor.control_orientation * anchor_weight +
            active.control_orientation * active_weight +
            buffer.control_orientation * buffer_weight
        ),
        temporal_orientation=(
            anchor.temporal_orientation * anchor_weight +
            active.temporal_orientation * active_weight +
            buffer.temporal_orientation * buffer_weight
        ),
        agency_belief=(
            anchor.agency_belief * anchor_weight +
            active.agency_belief * active_weight +
            buffer.agency_belief * buffer_weight
        ),
        scale_5=(
            anchor.scale_5 * anchor_weight +
            active.scale_5 * active_weight +
            buffer.scale_5 * buffer_weight
        )
    )
    
    return composite


def calculate_dissonance(
    drift_monitor: DriftMonitor,
    asm_distance: float,
    asm_weight: float = 0.3,
    drift_weight: float = 0.7
) -> float:
    """
    Calculate overall dissonance level.
    Combines drift from anchor and ASM deviation.
    """
    # Normalize ASM distance (max possible ~12.7 for corner)
    asm_normalized = min(asm_distance / 12.7 * 100, 100)
    
    # Use aggregate drift anchor→active as primary drift measure
    drift_component = drift_monitor.aggregate_drift_anchor_active
    
    # Weighted combination
    dissonance = (asm_normalized * asm_weight) + (drift_component * drift_weight)
    
    return round(min(dissonance, 100), 2)


def apply_emotional_decay(
    current_asm: 'ASM',
    decay_rate: float,
    target_valence: float = 0.0,
    target_arousal: float = 0.0
) -> Tuple[float, float]:
    """
    Move ASM values toward equilibrium targets.
    decay_rate: 0.0 (no decay) to 1.0 (instant return)
    """
    new_valence = current_asm.valence + (target_valence - current_asm.valence) * decay_rate
    new_arousal = current_asm.arousal + (target_arousal - current_asm.arousal) * decay_rate
    
    return round(new_valence, 2), round(new_arousal, 2)


def check_promotion_eligibility(
    buffer_history: List[WorldviewScales],
    stability_cycles: int,
    consistency_threshold: float
) -> Tuple[bool, List[str]]:
    """
    Check if buffer values are stable enough to promote to active.
    Returns (is_eligible, list_of_scales_to_promote)
    """
    if len(buffer_history) < stability_cycles:
        return False, []
    
    recent = buffer_history[-stability_cycles:]
    eligible_scales = []
    
    scale_names = ["human_nature", "control_orientation", "temporal_orientation", 
                   "agency_belief", "scale_5"]
    
    for scale_name in scale_names:
        values = [getattr(h, scale_name) for h in recent]
        
        # Check consistency (low variance)
        if len(set(values)) == 1:  # All identical
            consistency = 100.0
        else:
            mean_val = np.mean(values)
            max_deviation = max(abs(v - mean_val) for v in values)
            # Consistency as inverse of deviation (scale 0-100)
            consistency = max(0, 100 - (max_deviation / 5.0 * 100))
        
        if consistency >= consistency_threshold:
            eligible_scales.append(scale_name)
    
    return len(eligible_scales) > 0, eligible_scales
```

---

## Summary: What You Have Now

| Component | Status |
|-----------|--------|
| **Architecture diagram** | ✓ Complete |
| **5 Worldview scales** | ✓ 4 defined, need 5th |
| **ASU Cycle definition** | ✓ Complete |
| **Data models (Python)** | ✓ Complete |
| **Core calculations** | ✓ Complete |
| **Dashboard config** | ✓ Complete |
| **File structure** | ✓ Complete |

---

## Remaining for Next Session

1. **Define Scale 5** - What's the 5th worldview dimension?

2. **WVM Module logic** - How Buffer updates from narrative conclusions

3. **ASM Module logic** - How narrative emotional content affects Valence/Arousal

4. **Adjustment Module** - The 3 resolution strategies in detail

5. **LLM Integration** - How DARA uses Claude/GPT for reasoning

6. **Dashboard UI** - Streamlit implementation

7. **Narrative Input Generator** - For experiments

---

**Shall I continue with any of these in this session, or is this a good stopping point to digest?**
